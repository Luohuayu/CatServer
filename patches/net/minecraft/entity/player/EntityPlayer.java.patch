--- ../src-base/minecraft/net/minecraft/entity/player/EntityPlayer.java
+++ ../src-work/minecraft/net/minecraft/entity/player/EntityPlayer.java
@@ -8,7 +8,6 @@
 import java.util.UUID;
 import javax.annotation.Nullable;
 import net.minecraft.block.Block;
-import net.minecraft.block.BlockBed;
 import net.minecraft.block.BlockHorizontal;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
@@ -32,7 +31,6 @@
 import net.minecraft.entity.passive.EntityPig;
 import net.minecraft.entity.passive.EntityTameable;
 import net.minecraft.entity.projectile.EntityFishHook;
-import net.minecraft.init.Blocks;
 import net.minecraft.init.Items;
 import net.minecraft.init.MobEffects;
 import net.minecraft.init.SoundEvents;
@@ -42,7 +40,6 @@
 import net.minecraft.inventory.IInventory;
 import net.minecraft.inventory.InventoryEnderChest;
 import net.minecraft.item.ItemArmor;
-import net.minecraft.item.ItemAxe;
 import net.minecraft.item.ItemElytra;
 import net.minecraft.item.ItemStack;
 import net.minecraft.item.ItemSword;
@@ -92,10 +89,26 @@
 import net.minecraft.world.WorldServer;
 import net.minecraftforge.fml.relauncher.Side;
 import net.minecraftforge.fml.relauncher.SideOnly;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.entity.CraftItem;
+import org.bukkit.entity.Player;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+import org.bukkit.event.entity.EntityCombustByEntityEvent;
+import org.bukkit.event.player.PlayerBedEnterEvent;
+import org.bukkit.event.player.PlayerBedLeaveEvent;
+import org.bukkit.event.player.PlayerDropItemEvent;
+import org.bukkit.event.player.PlayerVelocityEvent;
+import org.bukkit.util.Vector;
 
 @SuppressWarnings("incomplete-switch")
 public abstract class EntityPlayer extends EntityLivingBase
 {
+    public static final String PERSISTED_NBT_TAG = "PlayerPersisted";
+    protected java.util.HashMap<Integer, BlockPos> spawnChunkMap = new java.util.HashMap<Integer, BlockPos>();
+    protected java.util.HashMap<Integer, Boolean> spawnForcedMap = new java.util.HashMap<Integer, Boolean>();
+    public float eyeHeight = this.getDefaultEyeHeight();
+    public static final net.minecraft.entity.ai.attributes.IAttribute REACH_DISTANCE = new net.minecraft.entity.ai.attributes.RangedAttribute(null, "generic.reachDistance", 5.0D, 0.0D, 1024.0D).setShouldWatch(true);
+
     private static final DataParameter<Float> ABSORPTION = EntityDataManager.<Float>createKey(EntityPlayer.class, DataSerializers.FLOAT);
     private static final DataParameter<Integer> PLAYER_SCORE = EntityDataManager.<Integer>createKey(EntityPlayer.class, DataSerializers.VARINT);
     protected static final DataParameter<Byte> PLAYER_MODEL_FLAG = EntityDataManager.<Byte>createKey(EntityPlayer.class, DataSerializers.BYTE);
@@ -103,10 +116,10 @@
     protected static final DataParameter<NBTTagCompound> LEFT_SHOULDER_ENTITY = EntityDataManager.<NBTTagCompound>createKey(EntityPlayer.class, DataSerializers.COMPOUND_TAG);
     protected static final DataParameter<NBTTagCompound> RIGHT_SHOULDER_ENTITY = EntityDataManager.<NBTTagCompound>createKey(EntityPlayer.class, DataSerializers.COMPOUND_TAG);
     public InventoryPlayer inventory = new InventoryPlayer(this);
-    protected InventoryEnderChest enderChest = new InventoryEnderChest();
+    protected InventoryEnderChest enderChest = new InventoryEnderChest(this); // CraftBukkit - add "this" to constructor
     public Container inventoryContainer;
     public Container openContainer;
-    protected FoodStats foodStats = new FoodStats();
+    protected FoodStats foodStats = new FoodStats().setPlayer(this); // CraftBukkit - add "this" to constructor // CatServer - AppleCore Comp
     protected int flyToggleTimer;
     public float prevCameraYaw;
     public float cameraYaw;
@@ -117,9 +130,9 @@
     public double chasingPosX;
     public double chasingPosY;
     public double chasingPosZ;
-    protected boolean sleeping;
+    public boolean sleeping;
     public BlockPos bedLocation;
-    private int sleepTimer;
+    public int sleepTimer;
     public float renderOffsetX;
     @SideOnly(Side.CLIENT)
     public float renderOffsetY;
@@ -141,6 +154,10 @@
     @Nullable
     public EntityFishHook fishEntity;
 
+    public boolean fauxSleeping;
+    public String spawnWorld = "";
+    public int oldLevel = -1;
+
     protected CooldownTracker createCooldownTracker()
     {
         return new CooldownTracker();
@@ -156,6 +173,9 @@
         BlockPos blockpos = worldIn.getSpawnPoint();
         this.setLocationAndAngles((double)blockpos.getX() + 0.5D, (double)(blockpos.getY() + 1), (double)blockpos.getZ() + 0.5D, 0.0F, 0.0F);
         this.unused180 = 180.0F;
+
+        net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityEvent.EntityConstructing(this));
+        super.capabilities = net.minecraftforge.event.ForgeEventFactory.gatherCapabilities(this);
     }
 
     protected void applyEntityAttributes()
@@ -165,6 +185,7 @@
         this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.10000000149011612D);
         this.getAttributeMap().registerAttribute(SharedMonsterAttributes.ATTACK_SPEED);
         this.getAttributeMap().registerAttribute(SharedMonsterAttributes.LUCK);
+        this.getAttributeMap().registerAttribute(REACH_DISTANCE);
     }
 
     protected void entityInit()
@@ -180,6 +201,7 @@
 
     public void onUpdate()
     {
+        net.minecraftforge.fml.common.FMLCommonHandler.instance().onPlayerPreTick(this);
         this.noClip = this.isSpectator();
 
         if (this.isSpectator())
@@ -207,7 +229,7 @@
                 {
                     this.wakeUpPlayer(true, true, false);
                 }
-                else if (this.world.isDaytime())
+                else if (!net.minecraftforge.event.ForgeEventFactory.fireSleepingTimeCheck(this, this.bedLocation))
                 {
                     this.wakeUpPlayer(false, true, true);
                 }
@@ -367,6 +389,7 @@
                 this.setSize(f, f1);
             }
         }
+        net.minecraftforge.fml.common.FMLCommonHandler.instance().onPlayerPostTick(this);
     }
 
     public int getMaxInPortalTime()
@@ -399,7 +422,7 @@
         return SoundCategory.PLAYERS;
     }
 
-    protected int getFireImmuneTicks()
+    public int getFireImmuneTicks()
     {
         return 20;
     }
@@ -454,11 +477,11 @@
             this.cameraYaw = 0.0F;
             this.addMountedMovementStat(this.posX - d0, this.posY - d1, this.posZ - d2);
 
-            if (this.getRidingEntity() instanceof EntityPig)
+            if (this.getRidingEntity() instanceof EntityLivingBase && ((EntityLivingBase)this.getRidingEntity()).shouldRiderFaceForward(this))
             {
                 this.rotationPitch = f1;
                 this.rotationYaw = f;
-                this.renderYawOffset = ((EntityPig)this.getRidingEntity()).renderYawOffset;
+                this.renderYawOffset = ((EntityLivingBase)this.getRidingEntity()).renderYawOffset;
             }
         }
     }
@@ -490,7 +513,8 @@
         {
             if (this.getHealth() < this.getMaxHealth() && this.ticksExisted % 20 == 0)
             {
-                this.heal(1.0F);
+                // CraftBukkit - added regain reason of "REGEN" for filtering purposes.
+                this.heal(1.0F, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.REGEN);
             }
 
             if (this.foodStats.needFood() && this.ticksExisted % 10 == 0)
@@ -518,7 +542,7 @@
 
         this.setAIMoveSpeed((float)iattributeinstance.getAttributeValue());
         float f = MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
-        float f1 = (float)(Math.atan(-this.motionY * 0.20000000298023224D) * 15.0D);
+        float f1 = (float) (org.bukkit.craftbukkit.TrigMath.atan(-this.motionY * 0.20000000298023224D) * 15.0D);
 
         if (f > 0.1F)
         {
@@ -609,11 +633,15 @@
 
     public void onDeath(DamageSource cause)
     {
+        if (net.minecraftforge.common.ForgeHooks.onLivingDeath(this,  cause)) return;
         super.onDeath(cause);
         this.setSize(0.2F, 0.2F);
         this.setPosition(this.posX, this.posY, this.posZ);
         this.motionY = 0.10000000149011612D;
 
+        captureDrops = true;
+        capturedDrops.clear();
+
         if ("Notch".equals(this.getName()))
         {
             this.dropItem(new ItemStack(Items.APPLE, 1), true, false);
@@ -625,6 +653,9 @@
             this.inventory.dropAllItems();
         }
 
+        captureDrops = false;
+        if (!world.isRemote) net.minecraftforge.event.ForgeEventFactory.onPlayerDrops(this, cause, capturedDrops, recentlyHit > 0);
+
         if (cause != null)
         {
             this.motionX = (double)(-MathHelper.cos((this.attackedAtYaw + this.rotationYaw) * 0.017453292F) * 0.1F);
@@ -675,13 +706,25 @@
     @Nullable
     public EntityItem dropItem(boolean dropAll)
     {
-        return this.dropItem(this.inventory.decrStackSize(this.inventory.currentItem, dropAll && !this.inventory.getCurrentItem().isEmpty() ? this.inventory.getCurrentItem().getCount() : 1), false, true);
+        // Called only when dropped by Q or CTRL-Q
+        ItemStack stack = inventory.getCurrentItem();
+
+        if (stack.isEmpty())
+        {
+            return null;
+        }
+        if (stack.getItem().onDroppedByPlayer(stack, this))
+        {
+            int count = dropAll ? this.inventory.getCurrentItem().getCount() : 1;
+            return net.minecraftforge.common.ForgeHooks.onPlayerTossEvent(this, inventory.decrStackSize(inventory.currentItem, count), true);
+        }
+        return null;
     }
 
     @Nullable
     public EntityItem dropItem(ItemStack itemStackIn, boolean unused)
     {
-        return this.dropItem(itemStackIn, false, unused);
+        return net.minecraftforge.common.ForgeHooks.onPlayerTossEvent(this, itemStackIn, false);
     }
 
     @Nullable
@@ -723,6 +766,30 @@
                 entityitem.motionZ += Math.sin((double)f3) * (double)f2;
             }
 
+            // CraftBukkit start - fire PlayerDropItemEvent
+            Player player = (Player) this.getBukkitEntity();
+            CraftItem drop = new CraftItem(this.world.getServer(), entityitem);
+
+            PlayerDropItemEvent event = new PlayerDropItemEvent(player, drop);
+            this.world.getServer().getPluginManager().callEvent(event);
+
+            if (event.isCancelled()) {
+                org.bukkit.inventory.ItemStack cur = player.getInventory().getItemInHand();
+                if (traceItem && (cur == null || cur.getAmount() == 0)) {
+                    // The complete stack was dropped
+                    player.getInventory().setItemInHand(drop.getItemStack());
+                } else if (traceItem && cur.isSimilar(drop.getItemStack()) && cur.getAmount() < cur.getMaxStackSize() && drop.getItemStack().getAmount() == 1) {
+                    // Only one item is dropped
+                    cur.setAmount(cur.getAmount() + 1);
+                    player.getInventory().setItemInHand(cur);
+                } else {
+                    // Fallback
+                    player.getInventory().addItem(drop.getItemStack());
+                }
+                return null;
+            }
+            // CraftBukkit end
+
             ItemStack itemstack = this.dropItemAndGetStack(entityitem);
 
             if (traceItem)
@@ -741,12 +808,20 @@
 
     public ItemStack dropItemAndGetStack(EntityItem p_184816_1_)
     {
+        if (captureDrops) capturedDrops.add(p_184816_1_);
+        else // Forge: Don't indent to keep patch smaller.
         this.world.spawnEntity(p_184816_1_);
         return p_184816_1_.getItem();
     }
 
+    @Deprecated //Use location sensitive version below
     public float getDigSpeed(IBlockState state)
     {
+        return getDigSpeed(state, null);
+    }
+
+    public float getDigSpeed(IBlockState state, BlockPos pos)
+    {
         float f = this.inventory.getDestroySpeed(state);
 
         if (f > 1.0F)
@@ -798,12 +873,13 @@
             f /= 5.0F;
         }
 
-        return f;
+        f = net.minecraftforge.event.ForgeEventFactory.getBreakSpeed(this, state, f, pos);
+        return (f < 0 ? 0 : f);
     }
 
     public boolean canHarvestBlock(IBlockState state)
     {
-        return this.inventory.canHarvestBlock(state);
+        return net.minecraftforge.event.ForgeEventFactory.doPlayerHarvestCheck(this, state, this.inventory.canHarvestBlock(state));
     }
 
     public static void registerFixesPlayer(DataFixer fixer)
@@ -857,12 +933,28 @@
             this.wakeUpPlayer(true, true, false);
         }
 
+        this.spawnWorld = compound.getString("SpawnWorld");
+        if ("".equals(spawnWorld)) {
+            this.spawnWorld = this.world.getServer().getWorlds().get(0).getName();
+        }
+
         if (compound.hasKey("SpawnX", 99) && compound.hasKey("SpawnY", 99) && compound.hasKey("SpawnZ", 99))
         {
             this.spawnPos = new BlockPos(compound.getInteger("SpawnX"), compound.getInteger("SpawnY"), compound.getInteger("SpawnZ"));
             this.spawnForced = compound.getBoolean("SpawnForced");
         }
 
+        NBTTagList spawnlist = null;
+        spawnlist = compound.getTagList("Spawns", 10);
+        for (int i = 0; i < spawnlist.tagCount(); i++)
+        {
+            NBTTagCompound spawndata = (NBTTagCompound)spawnlist.getCompoundTagAt(i);
+            int spawndim = spawndata.getInteger("Dim");
+            this.spawnChunkMap.put(spawndim, new BlockPos(spawndata.getInteger("SpawnX"), spawndata.getInteger("SpawnY"), spawndata.getInteger("SpawnZ")));
+            this.spawnForcedMap.put(spawndim, spawndata.getBoolean("SpawnForced"));
+        }
+        this.spawnDimension = compound.getBoolean("HasSpawnDimensionSet") ? compound.getInteger("SpawnDimension") : null;
+
         this.foodStats.readNBT(compound);
         this.capabilities.readCapabilitiesFromNBT(compound);
 
@@ -896,6 +988,7 @@
         compound.setInteger("XpTotal", this.experienceTotal);
         compound.setInteger("XpSeed", this.xpSeed);
         compound.setInteger("Score", this.getScore());
+        net.minecraftforge.fml.common.FMLCommonHandler.instance().getDataFixer().writeVersionData(compound); //Moved down so it doesn't keep missing every MC update.
 
         if (this.spawnPos != null)
         {
@@ -905,6 +998,27 @@
             compound.setBoolean("SpawnForced", this.spawnForced);
         }
 
+        NBTTagList spawnlist = new NBTTagList();
+        for (java.util.Map.Entry<Integer, BlockPos> entry : this.spawnChunkMap.entrySet())
+        {
+            BlockPos spawn = entry.getValue();
+            if (spawn == null) continue;
+            Boolean forced = spawnForcedMap.get(entry.getKey());
+            if (forced == null) forced = false;
+            NBTTagCompound spawndata = new NBTTagCompound();
+            spawndata.setInteger("Dim", entry.getKey());
+            spawndata.setInteger("SpawnX", spawn.getX());
+            spawndata.setInteger("SpawnY", spawn.getY());
+            spawndata.setInteger("SpawnZ", spawn.getZ());
+            spawndata.setBoolean("SpawnForced", forced);
+            spawnlist.appendTag(spawndata);
+        }
+        compound.setTag("Spawns", spawnlist);
+
+        compound.setBoolean("HasSpawnDimensionSet", this.hasSpawnDimension());
+        if (this.hasSpawnDimension())
+            compound.setInteger("SpawnDimension", this.getSpawnDimension());
+
         this.foodStats.writeNBT(compound);
         this.capabilities.writeCapabilitiesToNBT(compound);
         compound.setTag("EnderItems", this.enderChest.saveInventoryToNBT());
@@ -918,10 +1032,12 @@
         {
             compound.setTag("ShoulderEntityRight", this.getRightShoulderEntity());
         }
+        compound.setString("SpawnWorld", spawnWorld); // CraftBukkit - fixes bed spawns for multiworld worlds
     }
 
     public boolean attackEntityFrom(DamageSource source, float amount)
     {
+        if (!net.minecraftforge.common.ForgeHooks.onPlayerAttack(this, source, amount)) return false;
         if (this.isEntityInvulnerable(source))
         {
             return false;
@@ -945,13 +1061,13 @@
                     this.wakeUpPlayer(true, true, false);
                 }
 
-                this.spawnShoulderEntities();
+                // this.spawnShoulderEntities(); // CraftBukkit - moved down
 
                 if (source.isDifficultyScaled())
                 {
                     if (this.world.getDifficulty() == EnumDifficulty.PEACEFUL)
                     {
-                        amount = 0.0F;
+                        return false; // CraftBukkit - f = 0.0f -> return false
                     }
 
                     if (this.world.getDifficulty() == EnumDifficulty.EASY)
@@ -965,7 +1081,14 @@
                     }
                 }
 
-                return amount == 0.0F ? false : super.attackEntityFrom(source, amount);
+                // return amount == 0.0F ? false : super.attackEntityFrom(source, amount);
+                // CraftBukkit start - Don't filter out 0 damage
+                boolean damaged = super.attackEntityFrom(source, amount);
+                if (damaged) {
+                    this.spawnShoulderEntities();
+                }
+                return damaged;
+                // CraftBukkit end
             }
         }
     }
@@ -974,7 +1097,7 @@
     {
         super.blockUsingShield(p_190629_1_);
 
-        if (p_190629_1_.getHeldItemMainhand().getItem() instanceof ItemAxe)
+        if (p_190629_1_.getHeldItemMainhand().getItem().canDisableShield(p_190629_1_.getHeldItemMainhand(), this.getActiveItemStack(), this, p_190629_1_))
         {
             this.disableShield(true);
         }
@@ -982,17 +1105,29 @@
 
     public boolean canAttackPlayer(EntityPlayer other)
     {
-        Team team = this.getTeam();
-        Team team1 = other.getTeam();
-
-        if (team == null)
-        {
-            return true;
+        // Team team = this.getTeam();
+        // Team team1 = other.getTeam();
+        // CraftBukkit start - Change to check OTHER player's scoreboard team according to API
+        // To summarize this method's logic, it's "Can parameter hurt this"
+        org.bukkit.scoreboard.Team team;
+        if (other instanceof EntityPlayerMP) {
+            EntityPlayerMP thatPlayer = (EntityPlayerMP) other;
+            team = thatPlayer.getBukkitEntity().getScoreboard().getPlayerTeam(thatPlayer.getBukkitEntity());
+            if (team == null || team.allowFriendlyFire()) {
+                return true;
+            }
+        } else {
+            // This should never be called, but is implemented anyway
+            org.bukkit.OfflinePlayer thisPlayer = other.world.getServer().getOfflinePlayer(other.getName());
+            team = other.world.getServer().getScoreboardManager().getMainScoreboard().getPlayerTeam(thisPlayer);
+            if (team == null || team.allowFriendlyFire()) {
+                return true;
+            }
         }
-        else
-        {
-            return !team.isSameTeam(team1) ? true : team.getAllowFriendlyFire();
+        if (this instanceof EntityPlayerMP) {
+            return !team.hasPlayer(((EntityPlayerMP) this).getBukkitEntity());
         }
+        return !team.hasPlayer(this.world.getServer().getOfflinePlayer(this.getName()));
     }
 
     protected void damageArmor(float damage)
@@ -1002,14 +1137,16 @@
 
     protected void damageShield(float damage)
     {
-        if (damage >= 3.0F && this.activeItemStack.getItem() == Items.SHIELD)
+        if (damage >= 3.0F && this.activeItemStack.getItem().isShield(this.activeItemStack, this))
         {
+            ItemStack copyBeforeUse = this.activeItemStack.copy();
             int i = 1 + MathHelper.floor(damage);
             this.activeItemStack.damageItem(i, this);
 
             if (this.activeItemStack.isEmpty())
             {
                 EnumHand enumhand = this.getActiveHand();
+                net.minecraftforge.event.ForgeEventFactory.onPlayerDestroyItem(this, copyBeforeUse, enumhand);
 
                 if (enumhand == EnumHand.MAIN_HAND)
                 {
@@ -1043,13 +1180,27 @@
 
     protected void damageEntity(DamageSource damageSrc, float damageAmount)
     {
+        this.damageEntity_CB(damageSrc, damageAmount);
+        Float f = 1902490120.01F; this.addExhaustion(f.floatValue()); // CatServer - AppleCore Comp
+    }
+
+    // TODO: Check if Cauldron way is correct
+    protected boolean damageEntity_CB(DamageSource damageSrc, float damageAmount)
+    {
+        if (true) {
+            return super.damageEntity_CB(damageSrc, damageAmount);
+        }
         if (!this.isEntityInvulnerable(damageSrc))
         {
-            damageAmount = this.applyArmorCalculations(damageSrc, damageAmount);
+            damageAmount = net.minecraftforge.common.ForgeHooks.onLivingHurt(this, damageSrc, damageAmount);
+            if (damageAmount <= 0) return false;
+            damageAmount = net.minecraftforge.common.ISpecialArmor.ArmorProperties.applyArmor(this, inventory.armorInventory, damageSrc, damageAmount);
+            if (damageAmount <= 0) return false;
             damageAmount = this.applyPotionDamageCalculations(damageSrc, damageAmount);
             float f = damageAmount;
             damageAmount = Math.max(damageAmount - this.getAbsorptionAmount(), 0.0F);
             this.setAbsorptionAmount(this.getAbsorptionAmount() - (f - damageAmount));
+            damageAmount = net.minecraftforge.common.ForgeHooks.onLivingDamage(this, damageSrc, damageAmount);
 
             if (damageAmount != 0.0F)
             {
@@ -1064,6 +1215,7 @@
                 }
             }
         }
+        return false;
     }
 
     public void openEditSign(TileEntitySign signTile)
@@ -1115,6 +1267,8 @@
         }
         else
         {
+            EnumActionResult cancelResult = net.minecraftforge.common.ForgeHooks.onInteractEntity(this, p_190775_1_, p_190775_2_);
+            if (cancelResult != null) return cancelResult;
             ItemStack itemstack = this.getHeldItem(p_190775_2_);
             ItemStack itemstack1 = itemstack.isEmpty() ? ItemStack.EMPTY : itemstack.copy();
 
@@ -1124,7 +1278,10 @@
                 {
                     itemstack.setCount(itemstack1.getCount());
                 }
-
+                if (!this.capabilities.isCreativeMode && itemstack.isEmpty())
+                {
+                    net.minecraftforge.event.ForgeEventFactory.onPlayerDestroyItem(this, itemstack1, p_190775_2_);
+                }
                 return EnumActionResult.SUCCESS;
             }
             else
@@ -1140,6 +1297,7 @@
                     {
                         if (itemstack.isEmpty() && !this.capabilities.isCreativeMode)
                         {
+                            net.minecraftforge.event.ForgeEventFactory.onPlayerDestroyItem(this, itemstack1, p_190775_2_);
                             this.setHeldItem(p_190775_2_, ItemStack.EMPTY);
                         }
 
@@ -1165,6 +1323,7 @@
 
     public void attackTargetEntityWithCurrentItem(Entity targetEntity)
     {
+        if (!net.minecraftforge.common.ForgeHooks.onPlayerAttackTarget(this, targetEntity)) return;
         if (targetEntity.canBeAttackedWithItem())
         {
             if (!targetEntity.hitByEntity(this))
@@ -1203,9 +1362,11 @@
                     boolean flag2 = flag && this.fallDistance > 0.0F && !this.onGround && !this.isOnLadder() && !this.isInWater() && !this.isPotionActive(MobEffects.BLINDNESS) && !this.isRiding() && targetEntity instanceof EntityLivingBase;
                     flag2 = flag2 && !this.isSprinting();
 
+                    net.minecraftforge.event.entity.player.CriticalHitEvent hitResult = net.minecraftforge.common.ForgeHooks.getCriticalHit(this, targetEntity, flag2, flag2 ? 1.5F : 1.0F);
+                    flag2 = hitResult != null;
                     if (flag2)
                     {
-                        f *= 1.5F;
+                        f *= hitResult.getDamageModifier();
                     }
 
                     f = f + f1;
@@ -1232,8 +1393,17 @@
 
                         if (j > 0 && !targetEntity.isBurning())
                         {
-                            flag4 = true;
-                            targetEntity.setFire(1);
+                            // flag4 = true;
+                            // targetEntity.setFire(1);
+                            // CraftBukkit start - Call a combust event when somebody hits with a fire enchanted item
+                            EntityCombustByEntityEvent combustEvent = new EntityCombustByEntityEvent(this.getBukkitEntity(), targetEntity.getBukkitEntity(), 1);
+                            org.bukkit.Bukkit.getPluginManager().callEvent(combustEvent);
+
+                            if (!combustEvent.isCancelled()) {
+                                flag4 = true;
+                                targetEntity.setFire(combustEvent.getDuration());
+                            }
+                            // CraftBukkit end
                         }
                     }
 
@@ -1268,8 +1438,10 @@
                             {
                                 if (entitylivingbase != this && entitylivingbase != targetEntity && !this.isOnSameTeam(entitylivingbase) && this.getDistanceSq(entitylivingbase) < 9.0D)
                                 {
-                                    entitylivingbase.knockBack(this, 0.4F, (double)MathHelper.sin(this.rotationYaw * 0.017453292F), (double)(-MathHelper.cos(this.rotationYaw * 0.017453292F)));
-                                    entitylivingbase.attackEntityFrom(DamageSource.causePlayerDamage(this), f3);
+                                    // CraftBukkit start - Only apply knockback if the damage hits
+                                    if (entitylivingbase.attackEntityFrom(DamageSource.causePlayerDamage(this).sweep(), f3)) {
+                                        entitylivingbase.knockBack(this, 0.4F, (double) MathHelper.sin(this.rotationYaw * 0.017453292F), (double) (-MathHelper.cos(this.rotationYaw * 0.017453292F)));
+                                    }
                                 }
                             }
 
@@ -1279,11 +1451,28 @@
 
                         if (targetEntity instanceof EntityPlayerMP && targetEntity.velocityChanged)
                         {
-                            ((EntityPlayerMP)targetEntity).connection.sendPacket(new SPacketEntityVelocity(targetEntity));
-                            targetEntity.velocityChanged = false;
-                            targetEntity.motionX = d1;
-                            targetEntity.motionY = d2;
-                            targetEntity.motionZ = d3;
+                            // CraftBukkit start - Add Velocity Event
+                            boolean cancelled = false;
+                            Player player = (Player) targetEntity.getBukkitEntity();
+                            org.bukkit.util.Vector velocity = new Vector( d1, d2, d3 );
+
+                            PlayerVelocityEvent event = new PlayerVelocityEvent(player, velocity.clone());
+                            world.getServer().getPluginManager().callEvent(event);
+
+                            if (event.isCancelled()) {
+                                cancelled = true;
+                            } else if (!velocity.equals(event.getVelocity())) {
+                                player.setVelocity(event.getVelocity());
+                            }
+
+                            if (!cancelled) {
+                                ((EntityPlayerMP) targetEntity).connection.sendPacket(new SPacketEntityVelocity(targetEntity));
+                                targetEntity.velocityChanged = false;
+                                targetEntity.motionX = d1;
+                                targetEntity.motionY = d2;
+                                targetEntity.motionZ = d3;
+                            }
+                            // CraftBukkit end
                         }
 
                         if (flag2)
@@ -1332,10 +1521,12 @@
 
                         if (!itemstack1.isEmpty() && entity instanceof EntityLivingBase)
                         {
+                            ItemStack beforeHitCopy = itemstack1.copy();
                             itemstack1.hitEntity((EntityLivingBase)entity, this);
 
                             if (itemstack1.isEmpty())
                             {
+                                net.minecraftforge.event.ForgeEventFactory.onPlayerDestroyItem(this, beforeHitCopy, EnumHand.MAIN_HAND);
                                 this.setHeldItem(EnumHand.MAIN_HAND, ItemStack.EMPTY);
                             }
                         }
@@ -1347,7 +1538,15 @@
 
                             if (j > 0)
                             {
-                                targetEntity.setFire(j * 4);
+                                // targetEntity.setFire(j * 4);
+                                // CraftBukkit start - Call a combust event when somebody hits with a fire enchanted item
+                                EntityCombustByEntityEvent combustEvent = new EntityCombustByEntityEvent(this.getBukkitEntity(), entity.getBukkitEntity(), j * 4);
+                                org.bukkit.Bukkit.getPluginManager().callEvent(combustEvent);
+
+                                if (!combustEvent.isCancelled()) {
+                                    entity.setFire(combustEvent.getDuration());
+                                }
+                                // CraftBukkit end
                             }
 
                             if (this.world instanceof WorldServer && f5 > 2.0F)
@@ -1357,7 +1556,8 @@
                             }
                         }
 
-                        this.addExhaustion(0.1F);
+                        this.addExhaustion(1902490120.01F); // CatServer - AppleCore Comp
+                        this.addExhaustion(world.spigotConfig.combatExhaustion); // Spigot - Change to use configurable value
                     }
                     else
                     {
@@ -1367,6 +1567,11 @@
                         {
                             targetEntity.extinguish();
                         }
+                        // CraftBukkit start - resync on cancelled event
+                        if (this instanceof EntityPlayerMP) {
+                            ((EntityPlayerMP) this).getBukkitEntity().updateInventory();
+                        }
+                        // CraftBukkit end
                     }
                 }
             }
@@ -1384,7 +1589,7 @@
 
         if (this.rand.nextFloat() < f)
         {
-            this.getCooldownTracker().setCooldown(Items.SHIELD, 100);
+            this.getCooldownTracker().setCooldown(this.getActiveItemStack().getItem(), 100);
             this.resetActiveHand();
             this.world.setEntityState(this, (byte)30);
         }
@@ -1440,39 +1645,43 @@
         return this.gameProfile;
     }
 
-    public EntityPlayer.SleepResult trySleep(BlockPos bedLocation)
+    public SleepResult trySleep(BlockPos bedLocation)
     {
-        EnumFacing enumfacing = (EnumFacing)this.world.getBlockState(bedLocation).getValue(BlockHorizontal.FACING);
+        SleepResult ret = net.minecraftforge.event.ForgeEventFactory.onPlayerSleepInBed(this, bedLocation);
+        if (ret != null) return ret;
+        final IBlockState state = this.world.isBlockLoaded(bedLocation) ? this.world.getBlockState(bedLocation) : null;
+        final boolean isBed = state != null && state.getBlock().isBed(state, this.world, bedLocation, this);
+        final EnumFacing enumfacing = isBed && state.getBlock() instanceof BlockHorizontal ? (EnumFacing)state.getValue(BlockHorizontal.FACING) : null;
 
         if (!this.world.isRemote)
         {
             if (this.isPlayerSleeping() || !this.isEntityAlive())
             {
-                return EntityPlayer.SleepResult.OTHER_PROBLEM;
+                return SleepResult.OTHER_PROBLEM;
             }
 
             if (!this.world.provider.isSurfaceWorld())
             {
-                return EntityPlayer.SleepResult.NOT_POSSIBLE_HERE;
+                return SleepResult.NOT_POSSIBLE_HERE;
             }
 
-            if (this.world.isDaytime())
+            if (!net.minecraftforge.event.ForgeEventFactory.fireSleepingTimeCheck(this, bedLocation))
             {
-                return EntityPlayer.SleepResult.NOT_POSSIBLE_NOW;
+                return SleepResult.NOT_POSSIBLE_NOW;
             }
 
             if (!this.bedInRange(bedLocation, enumfacing))
             {
-                return EntityPlayer.SleepResult.TOO_FAR_AWAY;
+                return SleepResult.TOO_FAR_AWAY;
             }
 
             double d0 = 8.0D;
             double d1 = 5.0D;
-            List<EntityMob> list = this.world.<EntityMob>getEntitiesWithinAABB(EntityMob.class, new AxisAlignedBB((double)bedLocation.getX() - 8.0D, (double)bedLocation.getY() - 5.0D, (double)bedLocation.getZ() - 8.0D, (double)bedLocation.getX() + 8.0D, (double)bedLocation.getY() + 5.0D, (double)bedLocation.getZ() + 8.0D), new EntityPlayer.SleepEnemyPredicate(this));
+            List<EntityMob> list = this.world.<EntityMob>getEntitiesWithinAABB(EntityMob.class, new AxisAlignedBB((double)bedLocation.getX() - 8.0D, (double)bedLocation.getY() - 5.0D, (double)bedLocation.getZ() - 8.0D, (double)bedLocation.getX() + 8.0D, (double)bedLocation.getY() + 5.0D, (double)bedLocation.getZ() + 8.0D), new SleepEnemyPredicate(this));
 
             if (!list.isEmpty())
             {
-                return EntityPlayer.SleepResult.NOT_SAFE;
+                return SleepResult.NOT_SAFE;
             }
         }
 
@@ -1481,11 +1690,24 @@
             this.dismountRidingEntity();
         }
 
+        // CraftBukkit start - fire PlayerBedEnterEvent
+        if (this.getBukkitEntity() instanceof Player) {
+            Player player = (Player) this.getBukkitEntity();
+            org.bukkit.block.Block bed = this.world.getWorld().getBlockAt(bedLocation.getX(), bedLocation.getY(), bedLocation.getZ());
+
+            PlayerBedEnterEvent event = new PlayerBedEnterEvent(player, bed);
+            this.world.getServer().getPluginManager().callEvent(event);
+
+            if (event.isCancelled()) {
+                return SleepResult.OTHER_PROBLEM;
+            }
+        }
+        // CraftBukkit end
+
         this.spawnShoulderEntities();
         this.setSize(0.2F, 0.2F);
 
-        if (this.world.isBlockLoaded(bedLocation))
-        {
+        if (enumfacing != null) {
             float f1 = 0.5F + (float)enumfacing.getFrontOffsetX() * 0.4F;
             float f = 0.5F + (float)enumfacing.getFrontOffsetZ() * 0.4F;
             this.setRenderOffsetForSleep(enumfacing);
@@ -1508,7 +1730,7 @@
             this.world.updateAllPlayersSleepingFlag();
         }
 
-        return EntityPlayer.SleepResult.OK;
+        return SleepResult.OK;
     }
 
     private boolean bedInRange(BlockPos p_190774_1_, EnumFacing p_190774_2_)
@@ -1517,6 +1739,7 @@
         {
             return true;
         }
+        else if (p_190774_2_ == null) return false;
         else
         {
             BlockPos blockpos = p_190774_1_.offset(p_190774_2_.getOpposite());
@@ -1532,13 +1755,14 @@
 
     public void wakeUpPlayer(boolean immediately, boolean updateWorldFlag, boolean setSpawn)
     {
+        net.minecraftforge.event.ForgeEventFactory.onPlayerWakeup(this, immediately, updateWorldFlag, setSpawn);
         this.setSize(0.6F, 1.8F);
-        IBlockState iblockstate = this.world.getBlockState(this.bedLocation);
+        IBlockState iblockstate = this.bedLocation == null ? null : this.world.getBlockState(this.bedLocation);
 
-        if (this.bedLocation != null && iblockstate.getBlock() == Blocks.BED)
+        if (this.bedLocation != null && iblockstate.getBlock().isBed(iblockstate, world, bedLocation, this))
         {
-            this.world.setBlockState(this.bedLocation, iblockstate.withProperty(BlockBed.OCCUPIED, Boolean.valueOf(false)), 4);
-            BlockPos blockpos = BlockBed.getSafeExitLocation(this.world, this.bedLocation, 0);
+            iblockstate.getBlock().setBedOccupied(world, bedLocation, this, false);
+            BlockPos blockpos = iblockstate.getBlock().getBedSpawnPosition(iblockstate, world, bedLocation, this);
 
             if (blockpos == null)
             {
@@ -1547,6 +1771,10 @@
 
             this.setPosition((double)((float)blockpos.getX() + 0.5F), (double)((float)blockpos.getY() + 0.1F), (double)((float)blockpos.getZ() + 0.5F));
         }
+        else
+        {
+            setSpawn = false;
+        }
 
         this.sleeping = false;
 
@@ -1555,6 +1783,23 @@
             this.world.updateAllPlayersSleepingFlag();
         }
 
+        // CraftBukkit start - fire PlayerBedLeaveEvent
+        if (this.getBukkitEntity() instanceof Player) {
+            Player player = (Player) this.getBukkitEntity();
+
+            org.bukkit.block.Block bed;
+            BlockPos blockposition = this.bedLocation;
+            if (blockposition != null) {
+                bed = this.world.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ());
+            } else {
+                bed = this.world.getWorld().getBlockAt(player.getLocation());
+            }
+
+            PlayerBedLeaveEvent event = new PlayerBedLeaveEvent(player, bed);
+            this.world.getServer().getPluginManager().callEvent(event);
+        }
+        // CraftBukkit end
+
         this.sleepTimer = immediately ? 0 : 100;
 
         if (setSpawn)
@@ -1565,15 +1810,16 @@
 
     private boolean isInBed()
     {
-        return this.world.getBlockState(this.bedLocation).getBlock() == Blocks.BED;
+        return net.minecraftforge.event.ForgeEventFactory.fireSleepingLocationCheck(this, this.bedLocation);
     }
 
     @Nullable
     public static BlockPos getBedSpawnLocation(World worldIn, BlockPos bedLocation, boolean forceSpawn)
     {
-        Block block = worldIn.getBlockState(bedLocation).getBlock();
+        IBlockState state = worldIn.getBlockState(bedLocation);
+        Block block = state.getBlock();
 
-        if (block != Blocks.BED)
+        if (!block.isBed(state, worldIn, bedLocation, null))
         {
             if (!forceSpawn)
             {
@@ -1588,16 +1834,17 @@
         }
         else
         {
-            return BlockBed.getSafeExitLocation(worldIn, bedLocation, 0);
+            return block.getBedSpawnPosition(state, worldIn, bedLocation, null);
         }
     }
 
     @SideOnly(Side.CLIENT)
     public float getBedOrientationInDegrees()
     {
-        if (this.bedLocation != null)
+        IBlockState state = this.bedLocation == null ? null : this.world.getBlockState(bedLocation);
+        if (state != null && state.getBlock().isBed(state, world, bedLocation, this))
         {
-            EnumFacing enumfacing = (EnumFacing)this.world.getBlockState(this.bedLocation).getValue(BlockHorizontal.FACING);
+            EnumFacing enumfacing = state.getBlock().getBedDirection(state, world, bedLocation);
 
             switch (enumfacing)
             {
@@ -1637,25 +1884,35 @@
 
     public BlockPos getBedLocation()
     {
-        return this.spawnPos;
+        return getBedLocation(this.dimension);
     }
 
+    @Deprecated // Use dimension-sensitive version.
     public boolean isSpawnForced()
     {
-        return this.spawnForced;
+        return isSpawnForced(this.dimension);
     }
 
     public void setSpawnPoint(BlockPos pos, boolean forced)
     {
+        if(net.minecraftforge.event.ForgeEventFactory.onPlayerSpawnSet(this, pos, forced)) return;
+        if (this.dimension != 0)
+        {
+            setSpawnChunk(pos, forced, this.dimension);
+            return;
+        }
+
         if (pos != null)
         {
             this.spawnPos = pos;
             this.spawnForced = forced;
+            this.spawnWorld = this.world.worldInfo.getWorldName();
         }
         else
         {
             this.spawnPos = null;
             this.spawnForced = false;
+            this.spawnWorld = "";
         }
     }
 
@@ -1691,11 +1948,13 @@
 
         if (this.isSprinting())
         {
-            this.addExhaustion(0.2F);
+            this.addExhaustion(1902490120.01F); // CatServer - AppleCore Comp
+            this.addExhaustion(world.spigotConfig.jumpSprintExhaustion); // Spigot - Change to use configurable value
         }
         else
         {
-            this.addExhaustion(0.05F);
+            this.addExhaustion(1902490120.01F); // CatServer - AppleCore Comp
+            this.addExhaustion(world.spigotConfig.jumpWalkExhaustion); // Spigot - Change to use configurable value
         }
     }
 
@@ -1714,7 +1973,10 @@
             this.motionY = d3 * 0.6D;
             this.jumpMovementFactor = f;
             this.fallDistance = 0.0F;
-            this.setFlag(7, false);
+            // this.setFlag(7, false);
+            if (getFlag(7) && !org.bukkit.craftbukkit.event.CraftEventFactory.callToggleGlideEvent(this, false).isCancelled()) {
+                this.setFlag(7, false);
+            }
         }
         else
         {
@@ -1740,7 +2002,8 @@
                 if (i > 0)
                 {
                     this.addStat(StatList.DIVE_ONE_CM, i);
-                    this.addExhaustion(0.01F * (float)i * 0.01F);
+                    float n = world.spigotConfig.swimMultiplier * (float) i * 0.01F; // AppleCore Comp
+                    this.addExhaustion(n); // Spigot
                 }
             }
             else if (this.isInWater())
@@ -1750,7 +2013,8 @@
                 if (j > 0)
                 {
                     this.addStat(StatList.SWIM_ONE_CM, j);
-                    this.addExhaustion(0.01F * (float)j * 0.01F);
+                    float n = world.spigotConfig.swimMultiplier * (float) j * 0.01F; // AppleCore Comp
+                    this.addExhaustion(n); // Spigot
                 }
             }
             else if (this.isOnLadder())
@@ -1769,17 +2033,20 @@
                     if (this.isSprinting())
                     {
                         this.addStat(StatList.SPRINT_ONE_CM, k);
-                        this.addExhaustion(0.1F * (float)k * 0.01F);
+                        float n = world.spigotConfig.sprintMultiplier * (float) k * 0.01F; // AppleCore Comp
+                        this.addExhaustion(n); // Spigot
                     }
                     else if (this.isSneaking())
                     {
                         this.addStat(StatList.CROUCH_ONE_CM, k);
-                        this.addExhaustion(0.0F * (float)k * 0.01F);
+                        float n = world.spigotConfig.otherMultiplier * (float) k * 0.01F; // AppleCore Comp
+                        this.addExhaustion(n); // Spigot
                     }
                     else
                     {
                         this.addStat(StatList.WALK_ONE_CM, k);
-                        this.addExhaustion(0.0F * (float)k * 0.01F);
+                        float n = world.spigotConfig.otherMultiplier * (float) k * 0.01F; // AppleCore Comp
+                        this.addExhaustion(n); // Spigot
                     }
                 }
             }
@@ -1839,6 +2106,10 @@
 
             super.fall(distance, damageMultiplier);
         }
+        else
+        {
+            net.minecraftforge.event.ForgeEventFactory.onPlayerFall(this, distance, damageMultiplier);
+        }
     }
 
     protected void doWaterSplashEffect()
@@ -1943,6 +2214,7 @@
 
     public void addExhaustion(float exhaustion)
     {
+        if (exhaustion == 1902490120.01F) return; // AppleCore Comp
         if (!this.capabilities.disableDamage)
         {
             if (!this.world.isRemote)
@@ -2115,10 +2387,16 @@
 
     protected void spawnShoulderEntities()
     {
-        this.spawnShoulderEntity(this.getLeftShoulderEntity());
-        this.setLeftShoulderEntity(new NBTTagCompound());
-        this.spawnShoulderEntity(this.getRightShoulderEntity());
-        this.setRightShoulderEntity(new NBTTagCompound());
+        // this.spawnShoulderEntity(this.getLeftShoulderEntity());
+        // this.setLeftShoulderEntity(new NBTTagCompound());
+        // this.spawnShoulderEntity(this.getRightShoulderEntity());
+        // this.setRightShoulderEntity(new NBTTagCompound());
+        if (this.spawnShoulderEntity_CB(this.getLeftShoulderEntity())) {
+            this.setLeftShoulderEntity(new NBTTagCompound());
+        }
+        if (this.spawnShoulderEntity_CB(this.getRightShoulderEntity())) {
+            this.setRightShoulderEntity(new NBTTagCompound());
+        }
     }
 
     private void spawnShoulderEntity(@Nullable NBTTagCompound p_192026_1_)
@@ -2137,6 +2415,23 @@
         }
     }
 
+    private boolean spawnShoulderEntity_CB(@Nullable NBTTagCompound p_192026_1_) // CraftBukkit void->boolean
+    {
+        if (!this.world.isRemote && !p_192026_1_.hasNoTags())
+        {
+            Entity entity = EntityList.createEntityFromNBT(p_192026_1_, this.world);
+
+            if (entity instanceof EntityTameable)
+            {
+                ((EntityTameable)entity).setOwnerId(this.entityUniqueID);
+            }
+
+            entity.setPosition(this.posX, this.posY + 0.699999988079071D, this.posZ);
+            return this.world.addEntity(entity, CreatureSpawnEvent.SpawnReason.SHOULDER_ENTITY);
+        }
+        return true;
+    }
+
     @SideOnly(Side.CLIENT)
     public boolean isInvisibleToPlayer(EntityPlayer player)
     {
@@ -2176,7 +2471,10 @@
 
     public ITextComponent getDisplayName()
     {
-        ITextComponent itextcomponent = new TextComponentString(ScorePlayerTeam.formatPlayerName(this.getTeam(), this.getName()));
+        ITextComponent itextcomponent = new TextComponentString("");
+        if (!prefixes.isEmpty()) for (ITextComponent prefix : prefixes) itextcomponent.appendSibling(prefix);
+        itextcomponent.appendSibling(new TextComponentString(ScorePlayerTeam.formatPlayerName(this.getTeam(), this.getDisplayNameString())));
+        if (!suffixes.isEmpty()) for (ITextComponent suffix : suffixes) itextcomponent.appendSibling(suffix);
         itextcomponent.getStyle().setClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, "/msg " + this.getName() + " "));
         itextcomponent.getStyle().setHoverEvent(this.getHoverEvent());
         itextcomponent.getStyle().setInsertion(this.getName());
@@ -2185,7 +2483,7 @@
 
     public float getEyeHeight()
     {
-        float f = 1.62F;
+        float f = eyeHeight;
 
         if (this.isPlayerSleeping())
         {
@@ -2368,7 +2666,7 @@
         return (NBTTagCompound)this.dataManager.get(LEFT_SHOULDER_ENTITY);
     }
 
-    protected void setLeftShoulderEntity(NBTTagCompound tag)
+    public void setLeftShoulderEntity(NBTTagCompound tag)
     {
         this.dataManager.set(LEFT_SHOULDER_ENTITY, tag);
     }
@@ -2378,7 +2676,7 @@
         return (NBTTagCompound)this.dataManager.get(RIGHT_SHOULDER_ENTITY);
     }
 
-    protected void setRightShoulderEntity(NBTTagCompound tag)
+    public void setRightShoulderEntity(NBTTagCompound tag)
     {
         this.dataManager.set(RIGHT_SHOULDER_ENTITY, tag);
     }
@@ -2421,13 +2719,175 @@
         return this.capabilities.isCreativeMode && this.canUseCommand(2, "");
     }
 
+    /**
+     * Opens a GUI with this player, uses FML's IGuiHandler system.
+     * Allows for extension by modders.
+     *
+     * @param mod The mod trying to open a GUI
+     * @param modGuiId GUI ID
+     * @param world Current World
+     * @param x Passed directly to IGuiHandler, data meaningless Typically world X position
+     * @param y Passed directly to IGuiHandler, data meaningless Typically world Y position
+     * @param z Passed directly to IGuiHandler, data meaningless Typically world Z position
+     */
+    public void openGui(Object mod, int modGuiId, World world, int x, int y, int z)
+    {
+        net.minecraftforge.fml.common.network.internal.FMLNetworkHandler.openGui(this, mod, modGuiId, world, x, y, z);
+    }
+
+
+    /* ======================================== FORGE START =====================================*/
+    /**
+     * A dimension aware version of getBedLocation.
+     * @param dimension The dimension to get the bed spawn for
+     * @return The player specific spawn location for the dimension.  May be null.
+     */
+    public BlockPos getBedLocation(int dimension)
+    {
+        return dimension == 0 ? spawnPos : spawnChunkMap.get(dimension);
+    }
+
+    /**
+     * A dimension aware version of isSpawnForced.
+     * Noramally isSpawnForced is used to determine if the respawn system should check for a bed or not.
+     * This just extends that to be dimension aware.
+     * @param dimension The dimension to get whether to check for a bed before spawning for
+     * @return The player specific spawn location for the dimension.  May be null.
+     */
+    public boolean isSpawnForced(int dimension)
+    {
+        if (dimension == 0) return this.spawnForced;
+        Boolean forced = this.spawnForcedMap.get(dimension);
+        return forced == null ? false : forced;
+    }
+
+    /**
+     * A dimension aware version of setSpawnChunk.
+     * This functions identically, but allows you to specify which dimension to affect, rather than affecting the player's current dimension.
+     * @param pos The spawn point to set as the player-specific spawn point for the dimension
+     * @param forced Whether or not the respawn code should check for a bed at this location (true means it won't check for a bed)
+     * @param dimension Which dimension to apply the player-specific respawn point to
+     */
+    public void setSpawnChunk(BlockPos pos, boolean forced, int dimension)
+    {
+        if (dimension == 0)
+        {
+            if (pos != null)
+            {
+                spawnPos = pos;
+                spawnForced = forced;
+            }
+            else
+            {
+                spawnPos = null;
+                spawnForced = false;
+            }
+            return;
+        }
+
+        if (pos != null)
+        {
+            spawnChunkMap.put(dimension, pos);
+            spawnForcedMap.put(dimension, forced);
+        }
+        else
+        {
+            spawnChunkMap.remove(dimension);
+            spawnForcedMap.remove(dimension);
+        }
+    }
+
+    private String displayname;
+
+    /**
+     * Returns the default eye height of the player
+     * @return player default eye height
+     */
+    public float getDefaultEyeHeight()
+    {
+        return 1.62F;
+    }
+
+    /**
+     * Get the currently computed display name, cached for efficiency.
+     * @return the current display name
+     */
+    public String getDisplayNameString()
+    {
+        if(this.displayname == null)
+        {
+            this.displayname = net.minecraftforge.event.ForgeEventFactory.getPlayerDisplayName(this, this.getName());
+        }
+        return this.displayname;
+    }
+
+    /**
+     * Force the displayed name to refresh
+     */
+    public void refreshDisplayName()
+    {
+        this.displayname = net.minecraftforge.event.ForgeEventFactory.getPlayerDisplayName(this, this.getName());
+    }
+
+    private final java.util.Collection<ITextComponent> prefixes = new java.util.LinkedList<ITextComponent>();
+    private final java.util.Collection<ITextComponent> suffixes = new java.util.LinkedList<ITextComponent>();
+
+    /**
+     * Add a prefix to the player's username in chat
+     * @param prefix The prefix
+     */
+    public void addPrefix(ITextComponent prefix) { prefixes.add(prefix); }
+
+    /**
+     * Add a suffix to the player's username in chat
+     * @param suffix The suffix
+     */
+    public void addSuffix(ITextComponent suffix) { suffixes.add(suffix); }
+
+    public java.util.Collection<ITextComponent> getPrefixes() { return this.prefixes; }
+    public java.util.Collection<ITextComponent> getSuffixes() { return this.suffixes; }
+
+    private final net.minecraftforge.items.IItemHandler playerMainHandler = new net.minecraftforge.items.wrapper.PlayerMainInvWrapper(inventory);
+    private final net.minecraftforge.items.IItemHandler playerEquipmentHandler = new net.minecraftforge.items.wrapper.CombinedInvWrapper(
+                    new net.minecraftforge.items.wrapper.PlayerArmorInvWrapper(inventory),
+                    new net.minecraftforge.items.wrapper.PlayerOffhandInvWrapper(inventory));
+    private final net.minecraftforge.items.IItemHandler playerJoinedHandler = new net.minecraftforge.items.wrapper.PlayerInvWrapper(inventory);
+
+    @SuppressWarnings("unchecked")
+    @Override
+    @Nullable
+    public <T> T getCapability(net.minecraftforge.common.capabilities.Capability<T> capability, @Nullable EnumFacing facing)
+    {
+        if (capability == net.minecraftforge.items.CapabilityItemHandler.ITEM_HANDLER_CAPABILITY)
+        {
+            if (facing == null) return (T) playerJoinedHandler;
+            else if (facing.getAxis().isVertical()) return (T) playerMainHandler;
+            else if (facing.getAxis().isHorizontal()) return (T) playerEquipmentHandler;
+        }
+        return super.getCapability(capability, facing);
+    }
+
+    @Override
+    public boolean hasCapability(net.minecraftforge.common.capabilities.Capability<?> capability, @Nullable EnumFacing facing)
+    {
+        return capability == net.minecraftforge.items.CapabilityItemHandler.ITEM_HANDLER_CAPABILITY || super.hasCapability(capability, facing);
+    }
+
+    @Nullable
+    private Integer spawnDimension;
+    public boolean hasSpawnDimension() { return spawnDimension != null; }
+    public int getSpawnDimension() { return spawnDimension != null ? spawnDimension : 0; }
+    public void setSpawnDimension(@Nullable Integer dimension) { this.spawnDimension = dimension; }
+
+    /* ======================================== FORGE END  =====================================*/
+
     public static enum EnumChatVisibility
     {
         FULL(0, "options.chat.visibility.full"),
         SYSTEM(1, "options.chat.visibility.system"),
         HIDDEN(2, "options.chat.visibility.hidden");
 
-        private static final EntityPlayer.EnumChatVisibility[] ID_LOOKUP = new EntityPlayer.EnumChatVisibility[values().length];
+        private static final EnumChatVisibility[] ID_LOOKUP = new EnumChatVisibility[values().length];
         private final int chatVisibility;
         private final String resourceKey;
 
@@ -2457,7 +2917,7 @@
 
         static
         {
-            for (EntityPlayer.EnumChatVisibility entityplayer$enumchatvisibility : values())
+            for (EnumChatVisibility entityplayer$enumchatvisibility : values())
             {
                 ID_LOOKUP[entityplayer$enumchatvisibility.chatVisibility] = entityplayer$enumchatvisibility;
             }
@@ -2488,4 +2948,9 @@
         OTHER_PROBLEM,
         NOT_SAFE;
     }
+
+    @Override
+    public CraftHumanEntity getBukkitEntity() {
+        return (CraftHumanEntity) super.getBukkitEntity();
+    }
 }
